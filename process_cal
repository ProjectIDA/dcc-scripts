#!/usr/bin/env python3

import os
import sys
import argparse
import shutil
import glob
from pathlib import Path

from fabulous.color import bold, blue, red
from numpy import pi, cos, sin, multiply, linspace  #, angle, complex128, polyval, polyfit, less_equal
import matplotlib
matplotlib.use('Qt4Agg')
import matplotlib.pyplot as plt

from ida.tui import input_yn, pick2, PickResult
from ida.instruments import CALTYPE_RBLF, CALTYPE_RBHF, \
    Q330_FIR_GAIN_1HZ, \
    Q330_FIR_FILTER_DELAY, \
    Q330_FIR_COEFFS
from ida.calibration.cal_info import CalInfo
from ida.calibration.process import prepare_cal_data, analyze_cal_component, compare_component_response
from ida.calibration.cross import cross_correlate
from ida.calibration.plots import cross_tf_plot, save_comp_response_comparison_plot
from ida.ctbto.messages import CTBTChannelResult, \
    ims2_calibrate_result_msg_header, \
    ims2_calibrate_result_msg_comp_info, \
    ims2_PAZ2_msg, \
    ims2_DIG2_msg, \
    ims2_FIR2_msg
from ida.signals.utils import compute_response

version = '0.3'

parser = argparse.ArgumentParser(description="Process random binary calibration data acquired by qcal.")
parser.add_argument('-v', '--version', action='version', version=version)
parser.add_argument('sta', help="IDA Station code", default='')
parser.add_argument('loc', help="IDA Location code", default='')
args = parser.parse_args()
# perhaps for non-idadcc execution
# parser.add_argument('-d', '--datadir', help='Data Directory containing LF and HF idacal/qcal miniseed and log files.')
# parser.add_argument('-r', '--response', help='IDA format poles/zeros sensor response file')

raw_dir = os.path.join(os.environ['IDA_CAL_RAW_DIR'], args.sta, args.loc)
if not os.path.exists(raw_dir):
    print(bold(red('ERROR: Directory {} does not exist. Please check the number and dial again.'.format(raw_dir))))
    sys.exit(1)

ci = CalInfo(os.environ['IDA_CAL_RAW_DIR'],
             os.environ['IDA_RESPONSES_CUR_DIR'],
             os.environ['IDA_RESPONSES_NOM_DIR'],
             os.environ['IDA_CAL_ANALYSIS_DIR'])
ci.sta = args.sta
ci.loc = args.loc
ndnt = ci.tui_indent + 1

def clean_analysis_files(filelist):
    for fn in filelist:
        os.remove(fn)

def publish_files(target_dir, filelist):
    for fn in filelist:
        aname = Path(fn).name
        shutil.copy2(fn, os.path.join(target_dir, aname))


def gen_tf_and_fig(cal_info, data_samp_rate, input_data, meas_data, cal_type, green_tol_limits, grey_tol_limits):

    if cal_type == CALTYPE_RBLF:
        eff_max_freq =  data_samp_rate
    elif cal_type == CALTYPE_RBHF:
        eff_max_freq = ci.opsr
    else:
        raise ValueError('Invalid cal_type: {}'.format(cal_type))
    tf_f, tf_amp, tf_pha, tf_coh = cross_correlate(data_samp_rate, input_data, meas_data)
    fig = cross_tf_plot(cal_info.sta, cal_info.loc, cal_info.chan,
                        cal_info.sensor, cal_info.lfdatestr, cal_type,
                        eff_max_freq, tf_f, tf_amp, tf_pha, tf_coh,
                        green_tol_lims=green_tol_limits, grey_tol_lims=grey_tol_limits)

    return tf_f, tf_amp, tf_pha, tf_coh, fig


def fit_menu(choice_list):
    result, choices, user_choice_groups, _ = pick2([choice_list],
                                                   title='Select Action', prompt='Enter selection ("q" => quit): ',
                                                   implicit_quit_q=True, menu_on_error=True,
                                                   err_message='Invalid choice. Please try again')

    return choices[0]

def user_quit():
    print(' ' * ndnt + bold(red('User quit.')))
    sys.exit(0)


if ci.collect_info():

    cur_dir = os.getcwd()
    output_filename_list = []

    analysis_date = ci.lfdatestr if ci.lfdatestr else ci.hfdatestr
    analysis_path = os.path.join(os.environ['IDA_CAL_ANALYSIS_DIR'], ci.sta, ci.loc, analysis_date)
    if not os.path.exists(analysis_path):
        os.makedirs(analysis_path, exist_ok=True)

    print(' '*ndnt + bold('All analysis output will be saved in:'), bold(blue(cur_dir)))

    # copy in starting reponse file
    aname = Path(ci.respfn).stem + '_start_{}'.format(ci.comp) + Path(ci.respfn).suffix
    if 'ipaz' not in aname:
        aname = aname + '.ipaz'
    shutil.copy2(ci.respfn, os.path.join(cur_dir, aname))
    output_filename_list.append(os.path.join(cur_dir, aname))

    # set up for matplotlib and TF plots
    plt.ion()
    green_tol_limits = (1.0, 1.0, 1.0)  # (amp_pcnt, pha_deg, coh)
    grey_tol_limits = (5.0, 5.0, 5.0)  # (amp_pcnt, pha_deg, coh)

    fit_paz = ci.fullpaz
    new_paz = ci.fullpaz
    cal_start_time = None

    if not ci.omit_lf:

        ci.print_info()

        print(' '*ndnt + bold('Computing LOW FREQ TF with starting response for: {}'.format(ci.comp)))
        samp_rate_lf, lf_start_time, lfinput, lfmeas, _, _, _, _, \
        freqs_lf, _, snr_lf, _= prepare_cal_data(ci.lfpath, ci.lffile, None, None,
                                                 ci.sensor, ci.comp, ci.fullpaz)
        cal_start_time = lf_start_time

        # compute TF (and plot fig)
        lftf_f, lftf_amp, lftf_pha, lftf_coh, lf_fig_start = gen_tf_and_fig(ci, samp_rate_lf, lfinput,
                                                                            lfmeas, CALTYPE_RBLF,
                                                                            green_tol_limits, grey_tol_limits)
        fn = '{}_{}_{}_tf_lf_start_{}.png'.format(ci.sensor.lower(), ci.sta.lower(), ci.loc, ci.comp)
        fnpath = os.path.join(cur_dir, fn)
        lf_fig_start.savefig(fnpath, dpi=400)
        output_filename_list.append(fnpath)

        action = fit_menu([('F', 'Fit New LOW FREQ Response'), ('A', 'Accept Current LOW FREQ Response')]).upper()
        if action == 'Q':
            clean_analysis_files(output_filename_list)
            user_quit()

        while action == 'F':

            res, err = ci.select_perturb_map(CALTYPE_RBLF)
            if res == PickResult.collect_quit:
                print(' '*ndnt + bold(red('User quit.')))
                sys.exit(1)

            ci.print_info()

            print(' '*ndnt + bold('\nFitting new LOW FREQ reponse for: {}'.format(ci.comp)))
            lftf = multiply(lftf_amp, (cos(lftf_pha * pi / 180) + 1j * sin(lftf_pha * pi / 180)))
            fit_paz = analyze_cal_component(ci.fullpaz, ci.lfpert, ci.hfpert, ci.opsr,
                                            lftf_f, lftf, None, None, CALTYPE_RBLF)
            fit_paz.h0 = 1

            print(' '*ndnt + bold('Recomputing LOW FREQ TF with new fit response for: {}'.format(ci.comp)))
            samp_rate_lf, lf_start_time, lfinput, lfmeas, _, _, _, _, \
            freqs_lf, freqs_hf, snr_lf, snr_hf = prepare_cal_data(ci.lfpath, ci.lffile, None, None,
                                                                  ci.sensor, ci.comp, fit_paz)

            # comute TF (and plot fig)
            lftf_f, lftf_amp, lftf_pha, lftf_coh, lf_fig_fit = gen_tf_and_fig(ci, samp_rate_lf, lfinput,
                                                                              lfmeas, CALTYPE_RBLF,
                                                                              green_tol_limits, grey_tol_limits)

            action = fit_menu([('F', 'Fit New LOW FREQ Response'),
                               ('A', 'Accept Current LOW FREQ Response'),
                               ('S', 'Use Starting Response')]).upper()
            if action == 'Q':
                clean_analysis_files(output_filename_list)
                user_quit()

            if action == 'A':
                new_paz = fit_paz
                fn = '{}_{}_{}_tf_lf_fit_{}.png'.format(ci.sensor.lower(), ci.sta.lower(), ci.loc, ci.comp)
                fnpath = os.path.join(cur_dir, fn)
                lf_fig_fit.savefig(fnpath, dpi=400)
                output_filename_list.append(fnpath)
            elif action == 'S':
                new_paz = ci.fullpaz

            plt.close(lf_fig_fit)

        plt.close(lf_fig_start)

    if not ci.omit_hf:

        ci.print_info()

        print(' '*ndnt + bold('Computing HIGH FREQ TF with starting response for: {}'.format(ci.comp)))
        _,_,_,_, samp_rate_hf, hf_start_time, hfinput, hfmeas, \
        _, freqs_hf, _, snr_hf = prepare_cal_data(None, None, ci.hfpath, ci.hffile,
                                                  ci.sensor, ci.comp, new_paz)
        cal_start_time = min(cal_start_time, hf_start_time) if cal_start_time else hf_start_time

        # compute TF (and plot fig)
        hftf_f, hftf_amp, hftf_pha, hftf_coh, hf_fig_start = gen_tf_and_fig(ci, samp_rate_hf, hfinput,
                                                                            hfmeas, CALTYPE_RBHF,
                                                                            green_tol_limits, grey_tol_limits)
        fn = '{}_{}_{}_tf_hf_start_{}.png'.format(ci.sensor.lower(), ci.sta.lower(), ci.loc, ci.comp)
        fnpath = os.path.join(cur_dir, fn)
        hf_fig_start.savefig(fnpath, dpi=400)
        output_filename_list.append(fnpath)

        action = fit_menu([('F', 'Fit New HIGH FREQ Response'), ('A', 'Accept Current HIGH FREQ Response')]).upper()
        if action == 'Q':
            clean_analysis_files(output_filename_list)
            user_quit()

        while action == 'F':

            res, err = ci.select_perturb_map(CALTYPE_RBHF, paz=new_paz)
            if res == PickResult.collect_quit:
                clean_analysis_files(output_filename_list)
                user_quit()

            ci.print_info()

            print(' '*ndnt + bold('\nFitting new HIGH FREQ reponse for: {}'.format(ci.comp)))
            hftf = multiply(hftf_amp, (cos(hftf_pha * pi / 180) + 1j * sin(hftf_pha * pi / 180)))
            fit_paz = analyze_cal_component(new_paz, ci.lfpert, ci.hfpert, ci.opsr,
                                            None, None, hftf_f, hftf, CALTYPE_RBHF)
            fit_paz.h0 = 1

            print(' '*ndnt + bold('Recomputing HIGH FREQ TF with new fit response for: {}'.format(ci.comp)))
            _, _, _, _, samp_rate_hf, hf_start_time, hfinput, hfmeas, \
            _, freqs_hf, _, snr_hf = prepare_cal_data(None, None, ci.hfpath, ci.hffile,
                                                      ci.sensor, ci.comp, fit_paz)

            # comute TF (and plot fig)
            hftf_f, hftf_amp, hftf_pha, hftf_coh, hf_fig_fit = gen_tf_and_fig(ci, samp_rate_hf, hfinput,
                                                                              hfmeas, CALTYPE_RBHF,
                                                                              green_tol_limits, grey_tol_limits)

            action = fit_menu([('F', 'Fit New HIGH FREQ Response'),
                               ('A', 'Accept Current HIGH FREQ Response'),
                               ('S', 'Use Starting Response')]).upper()
            if action == 'Q':
                clean_analysis_files(output_filename_list)
                user_quit()

            if action == 'A':
                new_paz = fit_paz
                fn = '{}_{}_{}_tf_hf_fit_{}.png'.format(ci.sensor.lower(), ci.sta.lower(), ci.loc, ci.comp)
                fnpath = os.path.join(cur_dir, fn)
                hf_fig_fit.savefig(fnpath, dpi=400)
                output_filename_list.append(fnpath)
            elif action == 'S':
                pass  # new_paz is already output from LF analisys or initial ci.fullpaz

            plt.close(hf_fig_fit)

        plt.close(hf_fig_start)

    new_fn = os.path.join(cur_dir, ci.new_filename_stem() + '.ipaz')
    new_paz.save(new_fn)
    output_filename_list.append(new_fn)
    print('\n' + ' '*ndnt + bold('Response saved to file for: {}'.format(ci.comp)), bold(blue(new_fn)))


    if (new_paz != ci.fullpaz) or (ci.is_ctbto() and (not ci.omit_lf) and (not ci.omit_hf)):
        # need to compute freq response for comparison plots (if response changed) or for ctbto regardless of change
        print(' '*ndnt + bold('Computing frequency response for: {}'.format(ci.comp)))
        # lets find "nice" number for resp length: i.e. a multiple of 20 * sample rate. So 0.05 and 1 hz in freqs exactly.
        resp_len = 360000
        freqs, _ = linspace(0, ci.opsr / 2, resp_len + 1, retstep=True)  # must start with 0hz
        bl_resp, new_resp, adev, pdev, _, _ = compare_component_response(freqs, ci.fullpaz, new_paz,
                                                                         norm_freq=0.05, mode='vel', phase_detrend=True)

        if (new_paz != ci.fullpaz):
            # only do comparison plots if response changed
            amp_fn = os.path.join(cur_dir, ci.new_filename_stem() + '_AMP_Resp_' + ci.comp + '.png')
            pha_fn = os.path.join(cur_dir, ci.new_filename_stem() + '_PHA_Resp_' + ci.comp + '.png')
            amp_fig, pha_fig = save_comp_response_comparison_plot(ci.sta.upper(), ci.chan.upper(), ci.loc,
                                                                  Path(ci.respfn).stem, Path(new_fn).stem,
                                                                  ci.sensor.upper(), cal_start_time, ci.opsr,
                                                                  resp_len + 1, 1.0,
                                                                  bl_resp, new_resp, adev, pdev)
            amp_fig.savefig(amp_fn, dpi=400)
            output_filename_list.append(amp_fn)
            pha_fig.savefig(pha_fn, dpi=400)
            output_filename_list.append(pha_fn)

        if ci.is_ctbto() and (not ci.omit_lf) and (not ci.omit_hf):

            # noinspection PyUnboundLocalVariable
            ctbto_inspec = (lftf_amp.min() >= 0.95) and (lftf_amp.max() <= 1.05) and \
                           (hftf_amp.min() >= 0.95) and (hftf_amp.max() <= 1.05) and \
                           (lftf_pha.min() >= -5) and (lftf_pha.max() <= 5) and \
                           (hftf_pha.min() >= -5) and (hftf_pha.max() <= 5)

            print(' '*ndnt + bold('Computing full system sensitivity @ 1Hz for: {}'.format(ci.comp)))

            # compute new a0 (using pre-normalized response)
            calper = 1.0
            bin_1hz_ndx = min([freq[0] for freq in enumerate(freqs) if freq[1] >= (1/calper)])
            resp_1hz = compute_response(1.0, new_paz)
            a0 = 1 / abs(resp_1hz[0])
            print(' '*ndnt + bold('A0 @ 1hz:'), bold(blue(a0)))

            # system sens to compute calib
            s1_sens = abs(new_resp[bin_1hz_ndx]) * \
                      ci.chn_stages.iloc[0].gnom * \
                      ci.chn_stages.iloc[0].gcalib
            s3_sens = ci.chn_stages.iloc[2].gnom * \
                      ci.chn_stages.iloc[2].gcalib
            s4_sens = Q330_FIR_GAIN_1HZ[int(ci.opsr)]
            sys_sens = s1_sens * s3_sens * s4_sens

            # convert cts/(m/s) to cts/m to nm/ct
            calib = 1 / (sys_sens * (2 * pi) / 1e9)
            print(' '*ndnt + bold('sys sens (CALIB nm/ct) @ 1 sec for {}: '.format(ci.comp)), bold(blue(calib)))

            ctbto_chan_res = CTBTChannelResult(channel=ci.chan, calib=calib, calper=1.0,
                                               sample_rate=ci.opsr,
                                               in_spec=ctbto_inspec, paz=new_paz, A0=a0)

            ims2_header = ims2_calibrate_result_msg_header(cal_start_time)
            comp_info = ims2_calibrate_result_msg_comp_info(ci.sta, ci.chan, ctbto_inspec, calib, calper)
            sensor_info = ims2_PAZ2_msg(ci.sta, ci.loc, ci.chan, ci.sensor, cal_start_time,
                                        ci.opsr, calib, calper, new_paz,
                                        a0 * ci.chn_stages.iloc[0].gnom * ci.chn_stages.iloc[0].gcalib)
            digi_info = ims2_DIG2_msg(2, ci.chn_stages.iloc[2].gnom * ci.chn_stages.iloc[2].gcalib,
                                      ci.opsr, 'Q330') + \
                        '\n' + \
                        ims2_FIR2_msg(3, 1.0, 1, Q330_FIR_FILTER_DELAY[int(ci.opsr)], 'A',
                                      'Q330 Fir filter @ {}Hz'.format(ci.opsr), Q330_FIR_COEFFS[int(ci.opsr)])

            ims_msg_hdr_fn = os.path.join(cur_dir, 'IMS2_CR_{}_{}_{}_HDR.txt'.format(ci.sta.upper(),
                                                                                     ci.sensor.upper(),
                                                                                     analysis_date.replace('-', '')))
            with open(ims_msg_hdr_fn, 'wt') as ofl:
                ofl.write(ims2_header + '\n')
                output_filename_list.append(ims_msg_hdr_fn)

            ims_msg_comp_fn = os.path.join(cur_dir, 'IMS2_CR_{}_{}_{}_{}.txt'.format(ci.sta.upper(),
                                                                                     ci.sensor.upper(),
                                                                                     analysis_date.replace('-', ''),
                                                                                     ci.comp))
            with open(ims_msg_comp_fn, 'wt') as ofl:
                ofl.write(comp_info + '\n')
                ofl.write(sensor_info + '\n')
                ofl.write(digi_info + '\n')
                output_filename_list.append(ims_msg_comp_fn)

    elif ci.is_ctbto() and (ci.omit_lf or ci.omit_hf):
        print(' '*ndnt + bold(red('WARNING: Can not produce CTBTO results without both LF and HF analysis')))

    logfn = os.path.join(cur_dir, ci.new_filename_stem() + '.log')
    with open(logfn, 'wt') as ofl:
        ofl.write(str(ci))
        output_filename_list.append(logfn)

    if input_yn('\n' + ' '*ndnt + 'Publish {} component results to  {}  (y/n) ? :'.format(ci.comp, analysis_path)) == 'Y':
        print(output_filename_list)
        publish_files(analysis_path, output_filename_list)
        print('\n' + ' '*ndnt + bold(blue('Saved in current working directory and published to:')), bold(analysis_path), '\n')
        for fn in output_filename_list:
            print(bold(' '*(ndnt*2) + fn))
    else:
        print('\n' + ' '*ndnt + bold(blue('Saved in current working directory:')), '\n')
        for fn in output_filename_list:
            print(bold(' '*(ndnt*2) + fn))

    input(bold('\nHit ENTER/RETURN to exit...'))

